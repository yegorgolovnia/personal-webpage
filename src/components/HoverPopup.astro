---

---

<div id="sidebar-scene" class="perspective-container">
    <canvas id="stretch-canvas" class="stretch-overlay"></canvas>

    <aside id="hover-sidebar" class="sidebar-panel hidden">
        <div class="panel-surface">
            <!-- Decorative Border Line -->
            <div class="active-border"></div>

            <div class="content-wrapper">
                <div class="panel-label mono">DETAIL VIEW</div>

                <div class="title-block">
                    <h2 class="role-title"></h2>
                    <div class="company-sub mono"></div>
                </div>

                <div class="meta-row mono">
                    <span class="location-date"></span>
                </div>

                <div class="main-body">
                    <ul class="details-list"></ul>
                </div>

                <div class="footer-row">
                    <div class="tags-row mono"></div>
                </div>
            </div>
        </div>
    </aside>
</div>

<script>
    import { TextScramble, GlitchCanvas } from "../lib/glitch";

    const scene = document.getElementById("sidebar-scene");
    const sidebar = document.getElementById(
        "hover-sidebar",
    ) as HTMLElement | null;
    const canvas = document.getElementById(
        "stretch-canvas",
    ) as HTMLCanvasElement;

    if (sidebar && canvas) {
        // Initialize shared canvas logic
        const glitchCanvas = new GlitchCanvas(canvas);

        // Content Elements
        const contentWrapper = sidebar.querySelector(
            ".content-wrapper",
        ) as HTMLElement;
        const roleEl = sidebar.querySelector(".role-title") as HTMLElement;
        const compEl = sidebar.querySelector(".company-sub") as HTMLElement;
        const metaEl = sidebar.querySelector(".location-date") as HTMLElement;
        const listEl = sidebar.querySelector(".details-list") as HTMLElement;
        const tagsEl = sidebar.querySelector(".tags-row") as HTMLElement;

        let hideTimeout: ReturnType<typeof setTimeout>;
        const titleRestoreTimers = new WeakMap<TextScramble, ReturnType<typeof setTimeout>>();
        let isOpen = false;

        // Track active row to prevent duplicate triggers
        let currentHoveredRow: HTMLElement | null = null;
        let activeRowScramblers: TextScramble[] = [];

        const titleScrambler = new TextScramble(roleEl);
        const companyScrambler = new TextScramble(compEl);
        const metaScrambler = new TextScramble(metaEl);

        /* CANVAS LOGIC HANDLED BY GLITCHCANVAS */

        function triggerEntranceEffect() {
            glitchCanvas.triggerEntrance();
        }

        const fillData = (data: any) => {
            titleScrambler.setText(data.role || data.title || "", "normal");
            companyScrambler.setText(
                data.company || data.subtitle || "",
                "normal",
            );

            const loc = data.location ? data.location.toUpperCase() : "";
            const date = data.period || data.year || "";
            const metaStr = [loc, date].filter(Boolean).join(" • ");
            metaScrambler.setText(metaStr, "normal");

            listEl.innerHTML = "";
            if (data.hover_bullets && Array.isArray(data.hover_bullets)) {
                data.hover_bullets.slice(0, 3).forEach((txt: string) => {
                    const li = document.createElement("li");
                    listEl.appendChild(li);
                    const s = new TextScramble(li);
                    li.innerText = "";
                    s.setText(txt, "normal");
                });
            }

            tagsEl.innerHTML = "";
            if (data.tags && Array.isArray(data.tags)) {
                data.tags.forEach((tag: string) => {
                    const span = document.createElement("span");
                    span.className = "pill";
                    tagsEl.appendChild(span);
                    const s = new TextScramble(span);
                    span.innerText = "";
                    s.setText(tag, "normal");
                });
            }
        };

        function updateContent(data: any) {
            setTimeout(() => {
                fillData(data);
                contentWrapper.style.opacity = "1";
            }, 150);
        }

        // ROW INTERACTION
        function encryptRow(trigger: HTMLElement) {
            if (window.innerWidth < 1024) return;
            if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
            if (trigger === currentHoveredRow) return;

            restoreActiveRows();
            currentHoveredRow = trigger;

            const targets = [
                trigger.querySelector("h3"),
            ];

            targets.forEach((el) => {
                if (el) {
                    // DIMENSION LOCK: Prevent layout shift without cropping
                    const rect = el.getBoundingClientRect();
                    (el as HTMLElement).style.width = `${rect.width}px`;
                    (el as HTMLElement).style.height = `${rect.height}px`;
                    (el as HTMLElement).style.display = "inline-block";
                    (el as HTMLElement).style.overflow = "visible";

                    const s = new TextScramble(el as HTMLElement);
                    activeRowScramblers.push(s);
                    s.setText((el as HTMLElement).innerText, "encrypt");
                    el.classList.add("encrypted-row-text");

                    const existing = titleRestoreTimers.get(s);
                    if (existing) clearTimeout(existing);
                    const timer = setTimeout(() => {
                        s.restoreInstant();
                        s.el.classList.remove("encrypted-row-text");
                        s.el.style.width = "";
                        s.el.style.height = "";
                        s.el.style.display = "";
                        s.el.style.overflow = "";
                        titleRestoreTimers.delete(s);
                    }, 400);
                    titleRestoreTimers.set(s, timer);
                }
            });
        }

        function restoreActiveRows() {
            if (!currentHoveredRow) return;

            activeRowScramblers.forEach((s) => {
                s.el.classList.remove("encrypted-row-text");
                // Unlock dimensions
                s.el.style.width = "";
                s.el.style.height = "";
                s.el.style.display = "";
                s.el.style.overflow = "";
                s.restoreInstant();
            });
            activeRowScramblers = [];
            currentHoveredRow = null;
        }

        function openPanel(trigger: HTMLElement) {
            if (window.innerWidth < 1024) return;

            clearTimeout(hideTimeout);
            const dataStr = trigger.dataset.hoverData;
            if (!dataStr) return;

            try {
                const data = JSON.parse(dataStr);

                encryptRow(trigger);

                if (!isOpen) {
                    fillData(data);
                    contentWrapper.style.opacity = "1";
                    sidebar!.classList.remove("hidden");
                    sidebar!.classList.add("visible");
                    triggerEntranceEffect();
                    document.body.classList.add("hover-sidebar-open");
                    isOpen = true;
                } else {
                    updateContent(data);
                }
            } catch (e) {
                console.error(e);
            }
        }

        function scheduleHide() {
            hideTimeout = setTimeout(() => {
                // GLITCH EXIT: Blast stretch factor to Max
                glitchCanvas.triggerExit();

                sidebar!.classList.remove("visible");
                sidebar!.classList.add("hidden");
                document.body.classList.remove("hover-sidebar-open");

                isOpen = false;
            }, 100);
        }

        // LISTENERS
        document.addEventListener("mouseover", (e) => {
            const target = (e.target as HTMLElement).closest(
                ".hover-trigger",
            ) as HTMLElement;
            if (target) {
                openPanel(target);
            }
        });

        document.addEventListener("mouseout", (e) => {
            const target = (e.target as HTMLElement).closest(
                ".hover-trigger",
            ) as HTMLElement;
            if (target) {
                if (!target.contains(e.relatedTarget as Node)) {
                    restoreActiveRows();
                    scheduleHide();
                }
            }
        });

        // FAILSAFE
        document.addEventListener("mousemove", (e) => {
            if (
                currentHoveredRow &&
                !currentHoveredRow.contains(e.target as Node)
            ) {
                restoreActiveRows();
                scheduleHide();
            }
        });

        window.addEventListener("scroll", () => {
            if (currentHoveredRow) {
                restoreActiveRows();
                scheduleHide();
            }
        }, { passive: true });
    }
</script>

<style>
    .perspective-container {
        position: fixed;
        top: 0;
        right: 0;
        height: 100vh;
        width: 100vw;
        z-index: 90;
        pointer-events: none;
    }

    .stretch-overlay {
        position: absolute;
        inset: 0;
        z-index: 101;
        pointer-events: none;
    }

    .sidebar-panel {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: clamp(400px, 35vw, 600px);
        z-index: 100;
        transform: translateX(0);
        /* Default visible transition */
        transition:
            opacity 0.4s ease-out,
            filter 0.4s ease-out;
    }

    .sidebar-panel.hidden {
        opacity: 0;
        filter: blur(20px);
        /* Instant vanish transition */
        transition:
            opacity 0.1s ease-out,
            filter 0.1s ease-out;
    }
    .sidebar-panel.visible {
        opacity: 1;
        filter: blur(0);
    }

    .panel-surface {
        width: 100%;
        height: 100%;
        background: #030303;
        border-left: 1px solid var(--color-accent-subtle);
        display: flex;
        flex-direction: column;
        justify-content: center;
        position: relative;
    }

    .panel-surface::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image:
            repeating-linear-gradient(
                to bottom,
                rgba(255, 255, 255, 0.03),
                rgba(255, 255, 255, 0.03) 1px,
                transparent 1px,
                transparent 4px
            );
        opacity: 0.25;
        mix-blend-mode: screen;
        pointer-events: none;
        animation: scanline 8s linear infinite;
    }

    @keyframes scanline {
        0% { transform: translateY(0); }
        100% { transform: translateY(24px); }
    }

    :global(.dud-mono) {
        font-family: inherit;
        font-weight: inherit;
        color: var(--color-accent-subtle);
        opacity: 0.6;
    }
    :global(.dud-rgb) {
        font-family: inherit;
        font-weight: inherit;
        color: rgba(255, 100, 255, 0.8);
        text-shadow: 1px 0 rgba(100, 255, 100, 0.5);
        opacity: 0.9;
    }

    :global(.encrypted-row-text) {
        font-family: inherit;
        color: rgba(170, 255, 220, 0.6);
        text-shadow:
            0 0 6px rgba(100, 255, 200, 0.2),
            0 0 12px rgba(100, 255, 200, 0.12);

        /* OPTICAL COMPENSATION */
        font-size: 1em;
        letter-spacing: 0;
        line-height: inherit;
        white-space: nowrap;
    }

    /* FIX: Make internal spans ignore pointer so they don't re-trigger shuffle */
    :global(.encrypted-row-text span) {
        pointer-events: none;
        font-family: inherit;
        font-size: inherit;
        letter-spacing: inherit;
        line-height: inherit;
        display: inline-block;
    }

    .content-wrapper {
        display: flex;
        flex-direction: column;
        height: 100%;
        transition: opacity 0.3s ease-out;
        position: relative;
        z-index: 1;
        padding: 2rem;
        overflow-y: auto;
    }

    .panel-label {
        font-family: var(--font-mono);
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.4);
        text-transform: uppercase;
        letter-spacing: 0.1em;
        margin-bottom: 2rem;
    }

    .title-block {
        margin-bottom: 2rem;
    }

    .meta-row {
        font-family: var(--font-mono);
        display: flex;
        flex-wrap: wrap;
        row-gap: 0.5rem;
        column-gap: 1.5rem;
        font-size: 0.875rem;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 2.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        padding-bottom: 1.5rem;
    }

    .role-title {
        font-size: 1.875rem;
        font-weight: 700;
        color: #fff;
        line-height: 1.1;
        margin: 0 0 0.5rem 0;
    }

    .company-sub {
        font-family: var(--font-mono);
        color: rgba(255, 255, 255, 0.5);
        font-size: 1.125rem;
    }

    .main-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2rem;
    }

    .details-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    .details-list li {
        display: flex;
        gap: 0.75rem;
        color: rgba(255, 255, 255, 0.7);
        line-height: 1.625;
        font-size: 1.125rem;
    }
    .details-list li::before {
        content: "—";
        color: rgba(255, 255, 255, 0.3);
    }

    .footer-row {
        margin-top: auto;
        padding-top: 1.5rem;
        border-top: 1px solid rgba(255, 255, 255, 0.05);
    }
    .tags-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    .pill {
        font-family: var(--font-mono);
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.5);
        background: rgba(255, 255, 255, 0.05);
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.05);
    }

    @media (min-width: 768px) {
        .content-wrapper {
            padding: 3rem;
        }

        .role-title {
            font-size: 2.25rem;
        }
    }

    :global(body.hover-sidebar-open #content-shifter) {
        filter: brightness(0.8);
        transition: filter 0.2s ease;
    }

    @media (prefers-reduced-motion: reduce) {
        .panel-surface::after {
            animation: none;
        }
    }
</style>
